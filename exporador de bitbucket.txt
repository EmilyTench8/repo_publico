"""
Explorador Interactivo de Repositorios
======================================================
Este script permite conectarse a repositorios de Bitbucket/GitHub, 
explorar interactivamente su estructura de carpetas y descargar
el contenido de la ruta seleccionada, incluyendo detecci√≥n avanzada
de archivos de c√≥digo.
"""

import os
import sys
import time
import logging
import json
import requests
import getpass
import tempfile
import shutil
import asyncio
from typing import List, Dict, Any, Optional, Tuple, Union
from pathlib import Path
import base64

# Configuraci√≥n de logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler("repo_explorer.log")
    ]
)
logger = logging.getLogger("RepoExplorer")

# Constantes
TEMP_DIR = Path(tempfile.mkdtemp())
OUTPUT_DIR = Path("./archivos_descargados")
CONFIG_FILE = Path("./config.json")


def secure_input(prompt="Contrase√±a: "):
    """Alternativa a getpass que siempre usa input para entornos donde getpass no funciona."""
    print("‚ö†Ô∏è NOTA: Su entrada ser√° visible. Tenga cuidado en entornos compartidos.")
    return input(f"{prompt} (visible) ")


class ConfigManager:
    """Gestiona la configuraci√≥n de la aplicaci√≥n."""
    
    @staticmethod
    def load_config() -> Dict:
        """Carga la configuraci√≥n desde el archivo config.json."""
        if CONFIG_FILE.exists():
            try:
                with open(CONFIG_FILE, "r") as f:
                    return json.load(f)
            except Exception as e:
                logger.error(f"Error al cargar el archivo de configuraci√≥n: {e}")
                return {}
        return {}
    
    @staticmethod
    def save_config(config: Dict) -> None:
        """Guarda la configuraci√≥n en el archivo config.json."""
        with open(CONFIG_FILE, "w") as f:
            json.dump(config, f, indent=4)
    
    @staticmethod
    def get_credentials(repo_type: str) -> Dict:
        """Solicita las credenciales para el tipo de repositorio sin almacenamiento persistente."""
        credentials = {}
        
        if repo_type == "bitbucket":
            print("\nIngrese sus credenciales de Bitbucket (no se guardar√°n):")
            credentials["username"] = input("Usuario de Bitbucket: ")
            credentials["password"] = secure_input("Contrase√±a/Token de Bitbucket: ")
            credentials["workspace"] = input("Workspace de Bitbucket: ")
        elif repo_type == "github":
            print("\nIngrese sus credenciales de GitHub (no se guardar√°n):")
            credentials["token"] = secure_input("Token de GitHub: ")
            credentials["owner"] = input("Propietario/Organizaci√≥n de GitHub: ")
        
        # No se guardan las credenciales, son solo de memoria temporal
        return credentials


class RepositoryManager:
    """Gestiona las operaciones con repositorios (Bitbucket, GitHub)."""
    
    def __init__(self, repo_type: str):
        self.repo_type = repo_type
        self.credentials = ConfigManager.get_credentials(repo_type)
        self.base_url = self._get_base_url()
        self.session = requests.Session()
        self._setup_auth()
    
    def _get_base_url(self) -> str:
        """Devuelve la URL base para las API de los repositorios."""
        if self.repo_type == "bitbucket":
            return "https://api.bitbucket.org/2.0"
        elif self.repo_type == "github":
            return "https://api.github.com"
        else:
            raise ValueError(f"Tipo de repositorio no soportado: {self.repo_type}")
    
    def _setup_auth(self) -> None:
        """Configura la autenticaci√≥n para las solicitudes API."""
        if self.repo_type == "bitbucket":
            auth = (self.credentials["username"], self.credentials["password"])
            self.session.auth = auth
        elif self.repo_type == "github":
            self.session.headers.update({
                "Authorization": f"token {self.credentials['token']}",
                "Accept": "application/vnd.github.v3+json"
            })
    
    def list_projects(self) -> List[Dict]:
        """Lista todos los proyectos disponibles en el repositorio."""
        projects = []
        
        try:
            if self.repo_type == "bitbucket":
                workspace = self.credentials["workspace"]
                url = f"{self.base_url}/workspaces/{workspace}/projects"
                response = self.session.get(url)
                response.raise_for_status()
                data = response.json()
                
                for project in data.get("values", []):
                    projects.append({
                        "key": project["key"],
                        "name": project["name"],
                        "description": project.get("description", "Sin descripci√≥n")
                    })
                    
                # Manejar paginaci√≥n
                while "next" in data:
                    response = self.session.get(data["next"])
                    response.raise_for_status()
                    data = response.json()
                    
                    for project in data.get("values", []):
                        projects.append({
                            "key": project["key"],
                            "name": project["name"],
                            "description": project.get("description", "Sin descripci√≥n")
                        })
                
            elif self.repo_type == "github":
                owner = self.credentials["owner"]
                url = f"{self.base_url}/users/{owner}/repos"
                response = self.session.get(url)
                response.raise_for_status()
                data = response.json()
                
                for repo in data:
                    projects.append({
                        "key": repo["name"],
                        "name": repo["name"],
                        "description": repo.get("description", "Sin descripci√≥n")
                    })
                
                # Manejar paginaci√≥n
                while 'next' in response.links.keys():
                    response = self.session.get(response.links['next']['url'])
                    response.raise_for_status()
                    data = response.json()
                    
                    for repo in data:
                        projects.append({
                            "key": repo["name"],
                            "name": repo["name"],
                            "description": repo.get("description", "Sin descripci√≥n")
                        })
                    
        except requests.RequestException as e:
            logger.error(f"Error al obtener los proyectos: {e}")
            if hasattr(e, 'response') and hasattr(e.response, 'text'):
                logger.error(f"Respuesta del servidor: {e.response.text}")
            raise Exception(f"No se pudieron listar los proyectos: {str(e)}")
            
        return projects
    
    def list_repositories(self, project_key: str) -> List[Dict]:
        """Lista todos los repositorios dentro de un proyecto."""
        repos = []
        
        try:
            if self.repo_type == "bitbucket":
                workspace = self.credentials["workspace"]
                url = f"{self.base_url}/repositories/{workspace}"
                params = {"q": f"project.key=\"{project_key}\""}
                response = self.session.get(url, params=params)
                response.raise_for_status()
                data = response.json()
                
                for repo in data.get("values", []):
                    repos.append({
                        "slug": repo["slug"],
                        "name": repo["name"],
                        "description": repo.get("description", "Sin descripci√≥n")
                    })
                    
                # Manejar paginaci√≥n
                while "next" in data:
                    response = self.session.get(data["next"])
                    response.raise_for_status()
                    data = response.json()
                    
                    for repo in data.get("values", []):
                        repos.append({
                            "slug": repo["slug"],
                            "name": repo["name"],
                            "description": repo.get("description", "Sin descripci√≥n")
                        })
                    
            elif self.repo_type == "github":
                # Para GitHub, ya tenemos la lista de repos
                repos.append({
                    "slug": project_key,
                    "name": project_key,
                    "description": "Repositorio GitHub"
                })
                
        except requests.RequestException as e:
            logger.error(f"Error al obtener los repositorios: {e}")
            if hasattr(e, 'response') and hasattr(e.response, 'text'):
                logger.error(f"Respuesta del servidor: {e.response.text}")
            raise Exception(f"No se pudieron listar los repositorios: {str(e)}")
            
        return repos
        
    def list_branches(self, project_key: str, repo_slug: str) -> List[Dict]:
        """Lista todas las ramas disponibles en un repositorio."""
        branches = []
        
        try:
            if self.repo_type == "bitbucket":
                workspace = self.credentials["workspace"]
                url = f"{self.base_url}/repositories/{workspace}/{repo_slug}/refs/branches"
                response = self.session.get(url)
                response.raise_for_status()
                data = response.json()
                
                for branch in data.get("values", []):
                    branches.append({
                        "name": branch["name"],
                        "is_default": branch.get("default", False)
                    })
                    
                # Manejar paginaci√≥n
                while "next" in data:
                    response = self.session.get(data["next"])
                    response.raise_for_status()
                    data = response.json()
                    
                    for branch in data.get("values", []):
                        branches.append({
                            "name": branch["name"],
                            "is_default": branch.get("default", False)
                        })
            
            elif self.repo_type == "github":
                owner = self.credentials["owner"]
                url = f"{self.base_url}/repos/{owner}/{repo_slug}/branches"
                response = self.session.get(url)
                response.raise_for_status()
                data = response.json()
                
                # Obtener la rama predeterminada
                default_branch_name = None
                repo_info_url = f"{self.base_url}/repos/{owner}/{repo_slug}"
                repo_info_response = self.session.get(repo_info_url)
                if repo_info_response.status_code == 200:
                    repo_info = repo_info_response.json()
                    default_branch_name = repo_info.get("default_branch")
                
                for branch in data:
                    branches.append({
                        "name": branch["name"],
                        "is_default": branch["name"] == default_branch_name
                    })
                
                # Manejar paginaci√≥n
                while 'next' in response.links.keys():
                    response = self.session.get(response.links['next']['url'])
                    response.raise_for_status()
                    data = response.json()
                    
                    for branch in data:
                        branches.append({
                            "name": branch["name"],
                            "is_default": branch["name"] == default_branch_name
                        })
                
        except requests.RequestException as e:
            logger.error(f"Error al obtener las ramas: {e}")
            if hasattr(e, 'response') and hasattr(e.response, 'text'):
                logger.error(f"Respuesta del servidor: {e.response.text}")
            
            # Si falla, intentemos devolver al menos las ramas comunes
            if not branches:
                for common_branch in ["main", "master", "develop", "trunk"]:
                    branches.append({
                        "name": common_branch,
                        "is_default": common_branch == "main" or common_branch == "master"
                    })
                logger.info("No se pudieron obtener las ramas, usando ramas comunes")
        
        return branches
    
    def _get_default_branch(self, project_key: str, repo_slug: str) -> str:
        """Obtiene la rama predeterminada del repositorio."""
        default_branch = None
        
        try:
            if self.repo_type == "bitbucket":
                workspace = self.credentials["workspace"]
                
                # Intentar con diferentes variantes de may√∫sculas/min√∫sculas para el slug
                repo_slug_variants = [repo_slug, repo_slug.lower(), repo_slug.upper(), repo_slug.capitalize()]
                
                for slug_variant in repo_slug_variants:
                    # M√©todo 1: Intentar obtener desde la informaci√≥n del repositorio
                    repo_url = f"{self.base_url}/repositories/{workspace}/{slug_variant}"
                    logger.info(f"Intentando obtener informaci√≥n del repositorio desde: {repo_url}")
                    response = self.session.get(repo_url)
                    
                    if response.status_code == 200:
                        repo_info = response.json()
                        if "mainbranch" in repo_info and repo_info["mainbranch"]:
                            default_branch = repo_info["mainbranch"]["name"]
                            logger.info(f"Rama predeterminada obtenida desde mainbranch: {default_branch}")
                            return default_branch
                        break
                
                # M√©todo 2: Obtener todas las ramas y buscar la predeterminada o seleccionar por prioridad
                branches = self.list_branches(project_key, repo_slug)
                
                # Primero buscar una rama marcada como predeterminada
                for branch in branches:
                    if branch.get("is_default", False):
                        default_branch = branch["name"]
                        logger.info(f"Rama predeterminada obtenida desde is_default: {default_branch}")
                        return default_branch
                
                # Si no hay una rama predeterminada, usar una de las comunes por prioridad
                priority_branches = ["main", "master", "develop", "trunk", "release", "hotfix"]
                branch_names = [b["name"] for b in branches]
                
                for priority in priority_branches:
                    if priority in branch_names:
                        default_branch = priority
                        logger.info(f"Rama seleccionada por prioridad: {default_branch}")
                        return default_branch
                
                # Si ninguna coincide con las prioritarias, usar la primera rama disponible
                if branches:
                    default_branch = branches[0]["name"]
                    logger.info(f"Usando primera rama disponible: {default_branch}")
                    return default_branch
                
                # Si a√∫n no hay ramas, intentar algunas comunes
                logger.warning("No se encontraron ramas. Intentando con ramas comunes.")
                return "main"  # Intentar con 'main' como √∫ltimo recurso
                
            elif self.repo_type == "github":
                owner = self.credentials["owner"]
                
                # Obtener la informaci√≥n del repositorio
                repo_url = f"{self.base_url}/repos/{owner}/{repo_slug}"
                response = self.session.get(repo_url)
                
                if response.status_code == 200:
                    repo_info = response.json()
                    default_branch = repo_info.get("default_branch")
                    if default_branch:
                        logger.info(f"Rama predeterminada de GitHub: {default_branch}")
                        return default_branch
                
                # Si no se puede obtener, intentar con ramas comunes
                logger.warning("No se pudo obtener la rama predeterminada de GitHub. Intentando con ramas comunes.")
                return "main"  # Intentar con 'main' como √∫ltimo recurso
                
        except Exception as e:
            logger.error(f"Error al obtener la rama predeterminada: {e}")
            
        # Si todo falla, devolver 'main' como valor predeterminado
        logger.warning("Usando 'main' como rama predeterminada por defecto")
        return "main"
    
    def get_folder_contents(self, project_key: str, repo_slug: str, path: str = "", branch: str = None) -> List[Dict]:
        """Obtiene el contenido de una carpeta espec√≠fica del repositorio."""
        contents = []
        
        try:
            # Si no se especifica rama, obtener la predeterminada
            if not branch:
                branch = self._get_default_branch(project_key, repo_slug)
            
            if self.repo_type == "bitbucket":
                workspace = self.credentials["workspace"]
                
                # Modificaci√≥n: Intentar con may√∫sculas/min√∫sculas diferentes
                repo_slug_variants = [repo_slug, repo_slug.lower(), repo_slug.upper(), repo_slug.capitalize()]
                
                success = False
                for slug_variant in repo_slug_variants:
                    # URL para obtener el contenido de la carpeta con diferentes variantes
                    url = f"{self.base_url}/repositories/{workspace}/{slug_variant}/src/{branch}"
                    if path:
                        url = f"{url}/{path}"
                    
                    logger.info(f"Intentando acceder a: {url}")
                    response = self.session.get(url)
                    
                    if response.status_code == 200:
                        success = True
                        data = response.json()
                        
                        # Procesar el contenido
                        for item in data.get("values", []):
                            item_type = "directory" if item.get("type") == "commit_directory" else "file"
                            item_path = item.get("path", "")
                            
                            contents.append({
                                "name": item_path.split("/")[-1] if "/" in item_path else item_path,
                                "path": item_path,
                                "type": item_type,
                                "size": item.get("size", 0) if item_type == "file" else None
                            })
                        break
                
                if not success:
                    # Intento alternativo: usar API de contenido mediante refs
                    try:
                        logger.info("Intentando m√©todo alternativo para obtener contenido...")
                        
                        # Intentar con diferentes variantes de may√∫sculas/min√∫sculas
                        for slug_variant in repo_slug_variants:
                            refs_url = f"{self.base_url}/repositories/{workspace}/{slug_variant}/refs/branches/{branch}"
                            logger.info(f"Probando refs URL: {refs_url}")
                            refs_response = self.session.get(refs_url)
                            
                            if refs_response.status_code == 200:
                                branch_data = refs_response.json()
                                target_hash = branch_data.get("target", {}).get("hash")
                                
                                if target_hash:
                                    commit_url = f"{self.base_url}/repositories/{workspace}/{slug_variant}/src/{target_hash}/"
                                    if path:
                                        commit_url = f"{commit_url}{path}"
                                    
                                    logger.info(f"Usando commit hash: {commit_url}")
                                    commit_response = self.session.get(commit_url)
                                    
                                    if commit_response.status_code == 200:
                                        commit_data = commit_response.json()
                                        for item in commit_data.get("values", []):
                                            item_type = "directory" if item.get("type") == "commit_directory" else "file"
                                            item_path = item.get("path", "")
                                            
                                            contents.append({
                                                "name": item_path.split("/")[-1] if "/" in item_path else item_path,
                                                "path": item_path,
                                                "type": item_type,
                                                "size": item.get("size", 0) if item_type == "file" else None
                                            })
                                        success = True
                                        break
                            
                            # Si √©xito con esta variante, salir del bucle
                            if success:
                                break
                        
                        # √öLTIMO RECURSO: Probar directamente con las APIs de navegaci√≥n
                        if not success:
                            logger.info("Intentando acceso directo a navegaci√≥n de repo...")
                            
                            # API de navegaci√≥n (nuevo formato)
                            browse_url = f"https://api.bitbucket.org/2.0/repositories/{workspace}/{repo_slug}/browse"
                            if path:
                                browse_url = f"{browse_url}/{path}"
                            
                            logger.info(f"Probando URL de navegaci√≥n: {browse_url}")
                            browse_response = self.session.get(browse_url)
                            
                            if browse_response.status_code == 200:
                                try:
                                    browse_data = browse_response.json()
                                    for item in browse_data.get("values", []):
                                        item_type = "directory" if item.get("type") == "commit_directory" else "file"
                                        item_path = item.get("path", "")
                                        
                                        contents.append({
                                            "name": item_path.split("/")[-1] if "/" in item_path else item_path,
                                            "path": item_path,
                                            "type": item_type,
                                            "size": item.get("size", 0) if item_type == "file" else None
                                        })
                                except:
                                    # Podr√≠a no ser JSON
                                    pass
                    except Exception as alt_error:
                        logger.error(f"Error en m√©todo alternativo: {alt_error}")
                    
            elif self.repo_type == "github":
                owner = self.credentials["owner"]
                
                # URL para obtener el contenido de la carpeta
                url = f"{self.base_url}/repos/{owner}/{repo_slug}/contents"
                if path:
                    url = f"{url}/{path}"
                url = f"{url}?ref={branch}"
                
                response = self.session.get(url)
                response.raise_for_status()
                data = response.json()
                
                # Asegurar que data sea una lista
                if not isinstance(data, list):
                    data = [data]
                
                # Procesar el contenido
                for item in data:
                    item_type = "directory" if item.get("type") == "dir" else "file"
                    
                    contents.append({
                        "name": item.get("name", ""),
                        "path": item.get("path", ""),
                        "type": item_type,
                        "size": item.get("size", 0) if item_type == "file" else None
                    })
            
        except requests.RequestException as e:
            logger.error(f"Error al obtener el contenido de la carpeta: {e}")
            if hasattr(e, 'response') and hasattr(e.response, 'text'):
                logger.error(f"Respuesta del servidor: {e.response.text}")
            
            # Si hay un error, intentar devolver alg√∫n contenido sugerido
            if path == "":
                # Para la ra√≠z, sugerir algunas carpetas comunes
                common_dirs = ["src", "lib", "app", "main", "docs", "tests", "IA", "proyectos", 
                               "innovacion", "BI", "rag_sescol", "seleccion_personal"]
                for dir_name in common_dirs:
                    contents.append({
                        "name": dir_name,
                        "path": dir_name,
                        "type": "directory",
                        "size": None,
                        "suggested": True  # Marcar como sugerido, no confirmado
                    })
                
                logger.info("Error al obtener contenido real, usando carpetas sugeridas")
                
                # Tambi√©n agregar un mensaje informativo para el usuario
                contents.append({
                    "name": "MENSAJE_INFO.txt",
                    "path": "MENSAJE_INFO.txt",
                    "type": "file",
                    "size": 100,
                    "suggested": True,
                    "info": "Este mensaje contiene informaci√≥n sobre el problema de acceso",
                    "content": "No se pudo acceder al contenido real del repositorio. Esto puede deberse a permisos, "
                               "problemas de conectividad o cambios en la estructura del repositorio. Las carpetas "
                               "que ves son solo sugerencias comunes. Intenta seleccionar una de ellas y explorarla, "
                               "o prueba con otra rama o repositorio."
                })
        
        return contents
    
    def download_folder(self, project_key: str, repo_slug: str, path: str, target_dir: Path, branch: str = None) -> Path:
        """Descarga una carpeta espec√≠fica del repositorio."""
        # Asegurar que el directorio de destino exista
        download_dir = target_dir / path.replace("/", "_") if path else target_dir / repo_slug
        download_dir.mkdir(parents=True, exist_ok=True)
        
        try:
            # Si no se especifica rama, obtener la predeterminada
            if not branch:
                branch = self._get_default_branch(project_key, repo_slug)
            
            logger.info(f"Descargando contenido de '{path or 'ra√≠z'}' del repositorio {repo_slug} (rama: {branch})...")
            
            # Intentar m√©todos alternativos si el normal falla
            success = False
            
            # M√©todo 1: API est√°ndar
            try:
                # Obtener el contenido de la carpeta
                folder_contents = self.get_folder_contents(project_key, repo_slug, path, branch)
                
                if folder_contents and not all(item.get("suggested", False) for item in folder_contents):
                    # Descargar cada elemento del contenido
                    for item in folder_contents:
                        if item.get("suggested", False):
                            # Saltar elementos sugeridos (no son reales)
                            continue
                        
                        item_path = item["path"]
                        item_type = item["type"]
                        
                        if item_type == "directory":
                            # Crear subdirectorio y descargar su contenido recursivamente
                            subdir = download_dir / item["name"]
                            subdir.mkdir(parents=True, exist_ok=True)
                            
                            # Llamada recursiva para descargar el contenido del subdirectorio
                            self._download_folder_recursive(project_key, repo_slug, item_path, subdir, branch)
                        else:
                            # Descargar archivo individual
                            self._download_file(project_key, repo_slug, item_path, download_dir, branch)
                    
                    success = True
                else:
                    logger.warning(f"M√©todo est√°ndar no encontr√≥ archivos reales. Intentando m√©todo alternativo...")
            except Exception as e:
                logger.error(f"Error en m√©todo est√°ndar de descarga: {e}")
            
            # M√©todo 2: Descargar directamente desde el navegador del repositorio
            if not success:
                try:
                    logger.info("Intentando m√©todo alternativo con URL de navegaci√≥n...")
                    
                    # Detectar si estamos usando Bitbucket o GitHub
                    if self.repo_type == "bitbucket":
                        workspace = self.credentials["workspace"]
                        base_path = f"https://bitbucket.org/{workspace}/{repo_slug}/src/{branch}/"
                        if path:
                            base_path += f"{path}/"
                            
                        # Intentar extraer el listado de archivos desde la p√°gina HTML
                        session = requests.Session()
                        session.auth = self.session.auth
                        headers = {
                            "Accept": "text/html,application/xhtml+xml,application/xml",
                            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
                        }
                        
                        response = session.get(base_path, headers=headers)
                        if response.status_code == 200:
                            html_content = response.text
                            
                            # Buscar enlaces a archivos (simplificado - no es un parser HTML completo)
                            import re
                            file_links = re.findall(r'href="[^"]*?/src/[^"]*?/([^"]+)"', html_content)
                            
                            file_count = 0
                            for file_link in file_links:
                                if "/" not in file_link and file_link != "..":  # Evitar subcarpetas y enlace de regreso
                                    # Construir la ruta completa al archivo
                                    file_path = f"{path}/{file_link}" if path else file_link
                                    
                                    # Descargar el archivo
                                    try:
                                        self._download_file(project_key, repo_slug, file_path, download_dir, branch)
                                        file_count += 1
                                    except Exception as file_e:
                                        logger.error(f"Error al descargar {file_path}: {file_e}")
                            
                            if file_count > 0:
                                logger.info(f"M√©todo alternativo descarg√≥ {file_count} archivos")
                                success = True
                
                except Exception as alt_e:
                    logger.error(f"Error en m√©todo alternativo: {alt_e}")
            
            # M√©todo 3: Buscar archivos con extensiones espec√≠ficas
            if not success:
                try:
                    logger.info("Buscando archivos con extensiones espec√≠ficas...")
                    code_extensions = [".py", ".java", ".js", ".ts", ".html", ".css", ".jsx", ".tsx", 
                                     ".php", ".c", ".cpp", ".cs", ".go", ".rb", ".sh", ".sql", 
                                     ".md", ".json", ".yml", ".yaml", ".xml", ".txt", ".docx", ".xlsx"]
                    
                    path_prefix = f"{path}/" if path else ""
                    
                    file_count = 0
                    for ext in code_extensions:
                        try:
                            # Intentar buscar archivos con esta extensi√≥n
                            file_path = f"{path_prefix}*{ext}"
                            logger.info(f"Buscando archivos: {file_path}")
                            
                            # Para Bitbucket, construir una URL especial para buscar por extensi√≥n
                            if self.repo_type == "bitbucket":
                                workspace = self.credentials["workspace"]
                                search_url = f"{self.base_url}/repositories/{workspace}/{repo_slug}/src/{branch}"
                                params = {"q": f"path:*{ext}"}
                                
                                response = self.session.get(search_url, params=params)
                                if response.status_code == 200:
                                    try:
                                        data = response.json()
                                        
                                        for item in data.get("values", []):
                                            if item.get("type") != "commit_directory" and item.get("path", "").lower().endswith(ext):
                                                item_path = item.get("path", "")
                                                
                                                # Comprobar si el archivo est√° en la carpeta solicitada
                                                if not path or item_path.startswith(path_prefix):
                                                    # Descargar el archivo
                                                    try:
                                                        file_name = item_path.split("/")[-1]
                                                        file_url = f"{self.base_url}/repositories/{workspace}/{repo_slug}/src/{branch}/{item_path}"
                                                        file_response = self.session.get(file_url)
                                                        
                                                        if file_response.status_code == 200:
                                                            with open(download_dir / file_name, "wb") as f:
                                                                f.write(file_response.content)
                                                            
                                                            logger.info(f"Archivo encontrado y descargado: {file_name}")
                                                            file_count += 1
                                                    except Exception as file_e:
                                                        logger.error(f"Error descargando {item_path}: {file_e}")
                                    except Exception as json_e:
                                        logger.error(f"Error procesando respuesta JSON: {json_e}")
                        except Exception as ext_e:
                            logger.error(f"Error buscando archivos {ext}: {ext_e}")
                    
                    if file_count > 0:
                        logger.info(f"Se encontraron y descargaron {file_count} archivos espec√≠ficos")
                        success = True
                except Exception as search_e:
                    logger.error(f"Error en b√∫squeda de archivos espec√≠ficos: {search_e}")
            
            logger.info(f"Descarga completada en: {download_dir}")
            return download_dir
            
        except Exception as e:
            logger.error(f"Error al descargar la carpeta: {e}")
            raise Exception(f"No se pudo descargar la carpeta: {str(e)}")
    
    def _download_folder_recursive(self, project_key: str, repo_slug: str, path: str, target_dir: Path, branch: str) -> None:
        """Descarga recursivamente el contenido de una carpeta."""
        try:
            # Obtener el contenido de la carpeta
            folder_contents = self.get_folder_contents(project_key, repo_slug, path, branch)
            
            if not folder_contents:
                return
            
            # Descargar cada elemento del contenido
            for item in folder_contents:
                if item.get("suggested", False):
                    continue
                
                item_path = item["path"]
                item_type = item["type"]
                
                if item_type == "directory":
                    # Crear subdirectorio y descargar su contenido recursivamente
                    subdir = target_dir / item["name"]
                    subdir.mkdir(parents=True, exist_ok=True)
                    
                    # Llamada recursiva para descargar el contenido del subdirectorio
                    self._download_folder_recursive(project_key, repo_slug, item_path, subdir, branch)
                else:
                    # Descargar archivo individual
                    self._download_file(project_key, repo_slug, item_path, target_dir, branch)
                    
        except Exception as e:
            logger.error(f"Error en descarga recursiva de {path}: {e}")
    
    def _download_file(self, project_key: str, repo_slug: str, file_path: str, target_dir: Path, branch: str) -> None:
        """Descarga un archivo individual del repositorio."""
        try:
            # Determinar el nombre del archivo y la estructura de directorios
            path_parts = file_path.split("/")
            file_name = path_parts[-1]
            
            # Crear estructura de directorios si es necesario
            if len(path_parts) > 1:
                dir_path = target_dir / "/".join(path_parts[:-1])
                dir_path.mkdir(parents=True, exist_ok=True)
                output_path = dir_path / file_name
            else:
                output_path = target_dir / file_name
            
            if self.repo_type == "bitbucket":
                workspace = self.credentials["workspace"]
                
                # Probar diferentes variantes del nombre del repositorio
                repo_slug_variants = [repo_slug, repo_slug.lower(), repo_slug.upper(), repo_slug.capitalize()]
                
                success = False
                for slug_variant in repo_slug_variants:
                    file_url = f"{self.base_url}/repositories/{workspace}/{slug_variant}/src/{branch}/{file_path}"
                    
                    response = self.session.get(file_url)
                    if response.status_code == 200:
                        with open(output_path, "wb") as f:
                            f.write(response.content)
                        
                        logger.info(f"Archivo descargado: {output_path}")
                        success = True
                        break
                
                # Si no se pudo descargar con el m√©todo normal, probar con un m√©todo alternativo
                if not success:
                    # Intentar m√©todo alternativo: usar API de contenido directo
                    try:
                        # Intentar m√©todo alternativo con la URL de navegaci√≥n directa
                        browse_url = f"https://bitbucket.org/{workspace}/{repo_slug}/raw/{branch}/{file_path}"
                        
                        headers = {
                            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
                        }
                        
                        browse_session = requests.Session()
                        browse_session.auth = self.session.auth
                        
                        browse_response = browse_session.get(browse_url, headers=headers)
                        
                        if browse_response.status_code == 200:
                            with open(output_path, "wb") as f:
                                f.write(browse_response.content)
                            
                            logger.info(f"Archivo descargado (m√©todo alternativo): {output_path}")
                            success = True
                    except Exception as alt_e:
                        logger.error(f"Error en m√©todo alternativo para {file_path}: {alt_e}")
                
                if not success:
                    logger.error(f"No se pudo descargar el archivo {file_path}")
                
            elif self.repo_type == "github":
                owner = self.credentials["owner"]
                file_url = f"{self.base_url}/repos/{owner}/{repo_slug}/contents/{file_path}?ref={branch}"
                
                response = self.session.get(file_url)
                response.raise_for_status()
                data = response.json()
                
                if "download_url" in data and data["download_url"]:
                    # Descargar usando la URL directa
                    download_response = self.session.get(data["download_url"])
                    download_response.raise_for_status()
                    
                    with open(output_path, "wb") as f:
                        f.write(download_response.content)
                elif "content" in data and data["encoding"] == "base64":
                    # Decodificar el contenido base64
                    content = base64.b64decode(data["content"])
                    
                    with open(output_path, "wb") as f:
                        f.write(content)
                else:
                    logger.error(f"No se pudo obtener el contenido del archivo: {file_path}")
            
            logger.info(f"Archivo descargado: {output_path}")
            
        except Exception as e:
            logger.error(f"Error al descargar el archivo {file_path}: {e}")
    
    def get_specific_file_content(self, project_key: str, repo_slug: str, file_path: str, branch: str = None) -> Optional[bytes]:
        """Obtiene el contenido de un archivo espec√≠fico."""
        try:
            if not branch:
                branch = self._get_default_branch(project_key, repo_slug)
                
            if self.repo_type == "bitbucket":
                workspace = self.credentials["workspace"]
                
                # Probar diferentes variantes del nombre del repositorio
                repo_slug_variants = [repo_slug, repo_slug.lower(), repo_slug.upper(), repo_slug.capitalize()]
                
                for slug_variant in repo_slug_variants:
                    file_url = f"{self.base_url}/repositories/{workspace}/{slug_variant}/src/{branch}/{file_path}"
                    logger.info(f"Accediendo a archivo espec√≠fico: {file_url}")
                    
                    response = self.session.get(file_url)
                    if response.status_code == 200:
                        return response.content
                
                logger.warning(f"No se pudo acceder al archivo {file_path}")
                return None
            
            elif self.repo_type == "github":
                owner = self.credentials["owner"]
                file_url = f"{self.base_url}/repos/{owner}/{repo_slug}/contents/{file_path}?ref={branch}"
                
                response = self.session.get(file_url)
                if response.status_code == 200:
                    data = response.json()
                    
                    if "download_url" in data and data["download_url"]:
                        download_response = self.session.get(data["download_url"])
                        if download_response.status_code == 200:
                            return download_response.content
                    elif "content" in data and data["encoding"] == "base64":
                        return base64.b64decode(data["content"])
                
                logger.warning(f"No se pudo acceder al archivo {file_path}")
                return None
                
        except Exception as e:
            logger.error(f"Error al obtener archivo espec√≠fico: {e}")
            return None


class RepositoryExplorer:
    """Interfaz interactiva para explorar y descargar contenido de repositorios."""
    
    def __init__(self):
        self.repo_manager = None
        self.project_key = None
        self.repo_slug = None
        self.current_branch = None
        
        # Crear directorio de salida si no existe
        OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
    
    async def run(self):
        """Ejecuta el explorador interactivo."""
        print("\n" + "=" * 80)
        print("  üîç EXPLORADOR INTERACTIVO DE REPOSITORIOS üîç")
        print("=" * 80 + "\n")
        
        # Seleccionar tipo de repositorio
        await self._select_repository_type()
        
        # Seleccionar proyecto
        if not await self._select_project():
            return
        
        # Seleccionar repositorio
        if not await self._select_repository():
            return
        
        # Seleccionar rama
        if not await self._select_branch():
            return
        
        # Explorar el repositorio
        await self._explore_repository()
    
    async def _select_repository_type(self):
        """Gu√≠a al usuario para seleccionar el tipo de repositorio."""
        print("\nSeleccione el tipo de repositorio:")
        print("1. Bitbucket")
        print("2. GitHub")
        
        while True:
            option = input("\nSeleccione una opci√≥n: ")
            
            if option == "1":
                repo_type = "bitbucket"
                break
            elif option == "2":
                repo_type = "github"
                break
            else:
                print("‚ùå Opci√≥n no v√°lida, por favor intente de nuevo.")
        
        # Crear gestor de repositorio
        self.repo_manager = RepositoryManager(repo_type)
        print(f"\n‚úÖ Conectado a {repo_type.capitalize()}")
    
    async def _select_project(self) -> bool:
        """Gu√≠a al usuario para seleccionar un proyecto."""
        try:
            print("\nObteniendo proyectos disponibles...")
            projects = self.repo_manager.list_projects()
            
            if not projects:
                print("‚ùå No se encontraron proyectos disponibles.")
                return False
            
            print("\nProyectos disponibles:")
            for i, project in enumerate(projects):
                print(f"{i+1}. {project['name']} - {project['description']}")
            
            while True:
                try:
                    project_idx = int(input("\nSeleccione un proyecto (n√∫mero): ")) - 1
                    if 0 <= project_idx < len(projects):
                        self.project_key = projects[project_idx]['key']
                        print(f"\n‚úÖ Proyecto seleccionado: {projects[project_idx]['name']}")
                        return True
                    else:
                        print("‚ùå √çndice de proyecto no v√°lido, por favor intente de nuevo.")
                except ValueError:
                    print("‚ùå Por favor ingrese un n√∫mero v√°lido.")
            
        except Exception as e:
            logger.error(f"Error al seleccionar proyecto: {e}")
            print(f"\n‚ùå Error: {str(e)}")
            return False
    
    async def _select_repository(self) -> bool:
        """Gu√≠a al usuario para seleccionar un repositorio."""
        try:
            print("\nObteniendo repositorios disponibles...")
            repos = self.repo_manager.list_repositories(self.project_key)
            
            if not repos:
                print("‚ùå No se encontraron repositorios disponibles en este proyecto.")
                return False
            
            print("\nRepositorios disponibles:")
            for i, repo in enumerate(repos):
                print(f"{i+1}. {repo['name']} - {repo['description']}")
            
            while True:
                try:
                    repo_idx = int(input("\nSeleccione un repositorio (n√∫mero): ")) - 1
                    if 0 <= repo_idx < len(repos):
                        self.repo_slug = repos[repo_idx]['slug']
                        print(f"\n‚úÖ Repositorio seleccionado: {repos[repo_idx]['name']}")
                        return True
                    else:
                        print("‚ùå √çndice de repositorio no v√°lido, por favor intente de nuevo.")
                except ValueError:
                    print("‚ùå Por favor ingrese un n√∫mero v√°lido.")
            
        except Exception as e:
            logger.error(f"Error al seleccionar repositorio: {e}")
            print(f"\n‚ùå Error: {str(e)}")
            return False
    
    async def _select_branch(self) -> bool:
        """Gu√≠a al usuario para seleccionar una rama."""
        try:
            print("\nObteniendo ramas disponibles...")
            branches = self.repo_manager.list_branches(self.project_key, self.repo_slug)
            
            if not branches:
                print("‚ö†Ô∏è No se encontraron ramas espec√≠ficas. Se intentar√° autodetectar la rama predeterminada.")
                self.current_branch = self.repo_manager._get_default_branch(self.project_key, self.repo_slug)
                print(f"Usando rama: {self.current_branch}")
                return True
            
            print("\nRamas disponibles:")
            default_branch_idx = 0
            for i, branch in enumerate(branches):
                is_default = branch.get("is_default", False)
                if is_default:
                    print(f"{i+1}. {branch['name']} (predeterminada)")
                    default_branch_idx = i
                else:
                    print(f"{i+1}. {branch['name']}")
            
            use_specific_branch = input("\n¬øDesea utilizar una rama espec√≠fica? (s/n): ").lower() == "s"
            
            if use_specific_branch:
                while True:
                    try:
                        branch_idx = int(input("Seleccione una rama (n√∫mero): ")) - 1
                        if 0 <= branch_idx < len(branches):
                            self.current_branch = branches[branch_idx]["name"]
                            print(f"\n‚úÖ Rama seleccionada: {branches[branch_idx]['name']}")
                            return True
                        else:
                            print("‚ùå √çndice de rama no v√°lido, por favor intente de nuevo.")
                    except ValueError:
                        print("‚ùå Por favor ingrese un n√∫mero v√°lido.")
            else:
                self.current_branch = branches[default_branch_idx]["name"] if branches else None
                if self.current_branch:
                    print(f"\n‚úÖ Usando rama predeterminada: {self.current_branch}")
                else:
                    print("\n‚ö†Ô∏è No se pudo determinar la rama predeterminada.")
                    self.current_branch = self.repo_manager._get_default_branch(self.project_key, self.repo_slug)
                    print(f"Usando rama: {self.current_branch}")
                return True
            
        except Exception as e:
            logger.error(f"Error al seleccionar rama: {e}")
            print(f"\n‚ùå Error: {str(e)}")
            # Intentar obtener una rama por defecto
            self.current_branch = self.repo_manager._get_default_branch(self.project_key, self.repo_slug)
            print(f"Usando rama por defecto: {self.current_branch}")
            return True
    
    async def _explore_repository(self):
        """Explora el repositorio interactivamente."""
        current_path = ""
        breadcrumb = []
        
        # Intentar con cada rama disponible si la seleccionada falla
        if self.current_branch:
            print(f"\nVerificando acceso a la rama {self.current_branch}...")
            # Probar la rama seleccionada
            contents_test = self.repo_manager.get_folder_contents(
                self.project_key, self.repo_slug, "", self.current_branch
            )
            
            if not contents_test or all(item.get("suggested", False) for item in contents_test):
                print(f"‚ö†Ô∏è No se pudo acceder a la rama {self.current_branch}.")
                print("Intentando probar diferentes combinaciones de may√∫sculas/min√∫sculas y ramas...")
                
                # Intentar con variantes de may√∫sculas en el slug
                slug_variants = [self.repo_slug, self.repo_slug.lower(), self.repo_slug.upper(), 
                                self.repo_slug.capitalize(), self.repo_slug.title()]
                
                # Listar todas las ramas para probarlas
                branches = self.repo_manager.list_branches(self.project_key, self.repo_slug)
                branch_names = [branch["name"] for branch in branches] + ["main", "master", "develop", "trunk", "production"]
                
                # Intentar con todas las combinaciones
                for slug in slug_variants:
                    for branch_name in branch_names:
                        if branch_name == self.current_branch and slug == self.repo_slug:
                            continue  # Ya probamos esta combinaci√≥n
                            
                        print(f"Probando: repositorio='{slug}', rama='{branch_name}'...")
                        contents_test = self.repo_manager.get_folder_contents(
                            self.project_key, slug, "", branch_name
                        )
                        
                        # Verificar si obtuvimos contenido real (no sugerido)
                        if contents_test and not all(item.get("suggested", False) for item in contents_test):
                            print(f"‚úÖ Combinaci√≥n accesible: repo='{slug}', rama='{branch_name}'")
                            self.repo_slug = slug
                            self.current_branch = branch_name
                            
                            # Mostrar un mensaje de que hemos cambiado la configuraci√≥n
                            print("\n" + "=" * 60)
                            print(f"‚ö†Ô∏è ATENCI√ìN: Cambiado a repositorio='{slug}', rama='{branch_name}'")
                            print("=" * 60)
                            
                            break
                    
                    # Si encontramos una combinaci√≥n que funciona, salir del bucle exterior
                    if contents_test and not all(item.get("suggested", False) for item in contents_test):
                        break
                
                # Si a√∫n no encontramos una combinaci√≥n que funcione, avisar al usuario
                if not contents_test or all(item.get("suggested", False) for item in contents_test):
                    print("\n" + "=" * 60)
                    print("‚ö†Ô∏è No se pudo acceder al contenido real del repositorio.")
                    print("Se mostrar√°n carpetas sugeridas para exploraci√≥n.")
                    print("=" * 60)
                    print("Posibles soluciones:")
                    print("1. Verifica que el token de acceso tenga permisos suficientes")
                    print("2. Confirma que el nombre del workspace, proyecto y repositorio son correctos")
                    print("3. Aseg√∫rate de que la rama existe y es accesible")
                    print("4. Intenta con otro repositorio o workspace")
                    print("=" * 60)
        
        while True:
            try:
                print("\n" + "=" * 60)
                if breadcrumb:
                    print(f"üìÇ Ruta actual: /{'/'.join(breadcrumb)}")
                else:
                    print("üìÇ Ruta actual: / (ra√≠z)")
                print("=" * 60)
                print(f"üåø Rama actual: {self.current_branch}")
                print("=" * 60)
                
                # Obtener el contenido de la carpeta actual
                contents = self.repo_manager.get_folder_contents(
                    self.project_key, self.repo_slug, current_path, self.current_branch
                )
                
                if not contents:
                    print("Esta carpeta est√° vac√≠a o no se pudo acceder a su contenido.")
                    # Preguntar si desea descargar esta carpeta de todos modos
                    download_empty = input("\n¬øDesea descargar esta carpeta vac√≠a? (s/n): ").lower() == "s"
                    if download_empty:
                        download_path = OUTPUT_DIR / f"{self.repo_slug}_{current_path.replace('/', '_')}"
                        download_path.mkdir(parents=True, exist_ok=True)
                        print(f"\n‚úÖ Carpeta vac√≠a creada en: {download_path}")
                    
                    # Preguntar si quiere volver atr√°s
                    go_back = input("\n¬øDesea volver a la carpeta anterior? (s/n): ").lower() == "s"
                    if go_back and breadcrumb:
                        breadcrumb.pop()
                        current_path = "/".join(breadcrumb)
                    else:
                        break
                    continue
                
                # Separar directorios y archivos
                directories = [item for item in contents if item["type"] == "directory"]
                files = [item for item in contents if item["type"] == "file"]
                
                # Mostrar directorios
                print("\nCarpetas:")
                if directories:
                    for i, directory in enumerate(directories):
                        print(f"{i+1}. üìÅ {directory['name']}")
                else:
                    print("(No hay carpetas)")
                
                # Mostrar archivos
                print("\nArchivos:")
                if files:
                    for i, file in enumerate(files):
                        size = file.get("size", 0)
                        size_str = f"({size / 1024:.1f} KB)" if size else ""
                        
                        # Verificar si es un archivo de informaci√≥n especial
                        if file.get("suggested", False) and file.get("info"):
                            print(f"{i+1}. ‚ÑπÔ∏è {file['name']} - {file.get('info')}")
                            if 'content' in file:
                                print(f"   {file['content']}")
                        else:
                            print(f"{i+1}. üìÑ {file['name']} {size_str}")
                else:
                    print("(No hay archivos)")
                
                # Opciones
                print("\nOpciones:")
                print("1. Entrar en una carpeta")
                print("2. Descargar esta carpeta")
                print("3. Buscar archivos de c√≥digo en este repositorio")
                print("4. Volver a la carpeta anterior")
                print("5. Cambiar de rama")
                print("6. Salir")
                
                option = input("\nSeleccione una opci√≥n: ")
                
                if option == "1":
                    # Entrar en una carpeta
                    if not directories:
                        print("‚ùå No hay carpetas para explorar.")
                        continue
                    
                    dir_idx = int(input(f"Seleccione una carpeta (1-{len(directories)}): ")) - 1
                    if 0 <= dir_idx < len(directories):
                        selected_dir = directories[dir_idx]
                        breadcrumb.append(selected_dir["name"])
                        current_path = selected_dir["path"]
                        print(f"\nüëâ Entrando en: {selected_dir['name']}")
                    else:
                        print("‚ùå √çndice de carpeta no v√°lido.")
                
                elif option == "2":
                    # Descargar esta carpeta
                    print(f"\nDescargando contenido de: {'/' + current_path if current_path else 'ra√≠z'}")
                    
                    download_path = self.repo_manager.download_folder(
                        self.project_key, self.repo_slug, current_path, 
                        OUTPUT_DIR, self.current_branch
                    )
                    
                    print(f"\n‚úÖ Contenido descargado en: {download_path}")
                    
                    continue_exploring = input("\n¬øDesea continuar explorando el repositorio? (s/n): ").lower() == "s"
                    if not continue_exploring:
                        break
                
                elif option == "3":
                    # Buscar archivos de c√≥digo en este repositorio
                    await self._search_code_files(current_path)
                
                elif option == "4":
                    # Volver atr√°s
                    if breadcrumb:
                        breadcrumb.pop()
                        current_path = "/".join(breadcrumb)
                        print("\nüëà Volviendo a la carpeta anterior...")
                    else:
                        print("‚ùå Ya est√° en la ra√≠z del repositorio.")
                
                elif option == "5":
                    # Cambiar de rama
                    branches = self.repo_manager.list_branches(self.project_key, self.repo_slug)
                    
                    print("\nRamas disponibles:")
                    for i, branch in enumerate(branches):
                        is_current = branch["name"] == self.current_branch
                        if is_current:
                            print(f"{i+1}. {branch['name']} (actual)")
                        else:
                            print(f"{i+1}. {branch['name']}")
                    
                    branch_idx = int(input("\nSeleccione una rama (n√∫mero): ")) - 1
                    if 0 <= branch_idx < len(branches):
                        self.current_branch = branches[branch_idx]["name"]
                        print(f"\n‚úÖ Rama cambiada a: {branches[branch_idx]['name']}")
                    else:
                        print("‚ùå √çndice de rama no v√°lido.")
                
                elif option == "6":
                    # Salir
                    break
                
                else:
                    print("‚ùå Opci√≥n no v√°lida.")
                
            except Exception as e:
                logger.error(f"Error durante la exploraci√≥n: {e}")
                print(f"\n‚ùå Error: {str(e)}")
                
                # Preguntar si quiere intentar continuar o salir
                retry = input("\n¬øDesea intentar continuar? (s/n): ").lower() == "s"
                if not retry:
                    break
        
        print("\n¬°Gracias por usar el Explorador de Repositorios!")
    
    async def _search_code_files(self, current_path: str = ""):
        """Busca archivos de c√≥digo en el repositorio y ofrece descargarlos."""
        print("\n" + "=" * 60)
        print("üîé BUSCANDO ARCHIVOS DE C√ìDIGO")
        print("=" * 60)
        
        print("Buscando archivos en todo el repositorio. Esto puede tardar un momento...")
        
        # Lista de extensiones de archivos de c√≥digo comunes
        code_extensions = [
            ".py", ".java", ".js", ".ts", ".html", ".css", ".scss", 
            ".jsx", ".tsx", ".php", ".rb", ".c", ".cpp", ".h", ".cs",
            ".go", ".rs", ".swift", ".kt", ".scala", ".vb", ".sh",
            ".ipynb", ".sql", ".xml", ".json", ".yaml", ".yml", ".md",
            ".docx", ".xlsx", ".pptx", ".pdf", ".txt"
        ]
        
        # Buscar para cada extensi√≥n
        all_files = []
        
        # M√©todo 1: Buscar usando la API de contenido
        for ext in code_extensions:
            try:
                # Intentamos obtener todos los archivos con esta extensi√≥n
                if self.repo_manager.repo_type == "bitbucket":
                    workspace = self.repo_manager.credentials["workspace"]
                    
                    # Construir URL base para b√∫squeda
                    search_url = f"{self.repo_manager.base_url}/repositories/{workspace}/{self.repo_slug}/src/{self.current_branch}"
                    
                    # Intentar usar la API de b√∫squeda si est√° disponible
                    try:
                        params = {"q": f"path:*{ext}"}
                        response = self.repo_manager.session.get(search_url, params=params)
                        
                        if response.status_code == 200:
                            data = response.json()
                            
                            for item in data.get("values", []):
                                if item.get("type") != "commit_directory" and item.get("path", "").lower().endswith(ext):
                                    all_files.append({
                                        "name": item.get("path", "").split("/")[-1],
                                        "path": item.get("path", ""),
                                        "type": "file",
                                        "size": item.get("size", 0)
                                    })
                    except Exception as search_e:
                        print(f"Error en b√∫squeda de archivos {ext}: {search_e}")
                        
                    # Si tenemos muy pocos resultados, intentar usar un m√©todo alternativo
                    if len(all_files) < 3:
                        # M√©todo alternativo: obtener toda la estructura y filtrar por extensi√≥n
                        try:
                            # Intentar usar el visor de c√≥digo de Bitbucket
                            browse_url = f"https://bitbucket.org/{workspace}/{self.repo_slug}/src/{self.current_branch}/"
                            headers = {
                                "Accept": "text/html,application/xhtml+xml,application/xml",
                                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
                            }
                            
                            browse_session = requests.Session()
                            browse_session.auth = self.repo_manager.session.auth
                            
                            browse_response = browse_session.get(browse_url, headers=headers)
                            
                            if browse_response.status_code == 200:
                                html_content = browse_response.text
                                
                                # Buscar enlaces a archivos con esta extensi√≥n
                                import re
                                pattern = f'href="[^"]*?/src/[^"]*?/([^"]*?{ext})"'
                                file_matches = re.findall(pattern, html_content)
                                
                                for file_path in file_matches:
                                    # Evitar duplicados
                                    if not any(item["path"] == file_path for item in all_files):
                                        all_files.append({
                                            "name": file_path.split("/")[-1],
                                            "path": file_path,
                                            "type": "file",
                                            "size": 0
                                        })
                        except Exception as browse_e:
                            print(f"Error en b√∫squeda alternativa: {browse_e}")
                
                # M√©todo similar para GitHub
                elif self.repo_manager.repo_type == "github":
                    # Implementar b√∫squeda similar para GitHub
                    pass
                    
            except Exception as e:
                print(f"Error buscando archivos {ext}: {e}")
        
        # Mostrar resultados
        if all_files:
            print(f"\nSe encontraron {len(all_files)} archivos de c√≥digo:")
            
            # Agrupar por extensi√≥n para una visualizaci√≥n m√°s clara
            files_by_ext = {}
            for file in all_files:
                ext = "." + file["name"].split(".")[-1] if "." in file["name"] else "sin extensi√≥n"
                if ext not in files_by_ext:
                    files_by_ext[ext] = []
                files_by_ext[ext].append(file)
            
            # Mostrar resumen por tipo de archivo
            print("\nResumen por tipo de archivo:")
            for ext, files in files_by_ext.items():
                print(f"{ext}: {len(files)} archivos")
            
            # Mostrar lista completa
            print("\nLista de archivos encontrados:")
            for i, file in enumerate(all_files):
                print(f"{i+1}. {file['path']}")
            
            # Preguntar si desea descargar todos los archivos
            download_all = input("\n¬øDesea descargar todos estos archivos? (s/n): ").lower() == "s"
            
            if download_all:
                # Crear directorio para la descarga
                download_dir = OUTPUT_DIR / f"{self.repo_slug}_archivos_codigo"
                download_dir.mkdir(parents=True, exist_ok=True)
                
                # Descargar cada archivo
                print(f"\nDescargando {len(all_files)} archivos...")
                downloaded = 0
                
                for file in all_files:
                    try:
                        # Determinar la ruta del archivo
                        file_path = file["path"]
                        
                        # Crear estructura de carpetas si es necesario
                        file_parts = file_path.split("/")
                        if len(file_parts) > 1:
                            subdir_path = download_dir / "/".join(file_parts[:-1])
                            subdir_path.mkdir(parents=True, exist_ok=True)
                        
                        # Descargar el archivo
                        try:
                            self.repo_manager._download_file(
                                self.project_key, self.repo_slug, file_path, 
                                download_dir, self.current_branch
                            )
                            downloaded += 1
                        except Exception as download_e:
                            print(f"Error descargando {file_path}: {download_e}")
                    except Exception as e:
                        print(f"Error procesando {file['path']}: {e}")
                
                print(f"\n‚úÖ Se descargaron {downloaded} de {len(all_files)} archivos en: {download_dir}")
            
            # Preguntar si desea seleccionar archivos espec√≠ficos
            else:
                select_files = input("\n¬øDesea seleccionar archivos espec√≠ficos para descargar? (s/n): ").lower() == "s"
                
                if select_files:
                    # Permitir seleccionar archivos espec√≠ficos
                    indices = input("\nIngrese los n√∫meros de los archivos separados por comas (ejemplo: 1,3,5): ")
                    try:
                        selected_indices = [int(idx.strip()) - 1 for idx in indices.split(",")]
                        selected_files = [all_files[idx] for idx in selected_indices if 0 <= idx < len(all_files)]
                        
                        if selected_files:
                            # Crear directorio para la descarga
                            download_dir = OUTPUT_DIR / f"{self.repo_slug}_archivos_seleccionados"
                            download_dir.mkdir(parents=True, exist_ok=True)
                            
                            # Descargar cada archivo seleccionado
                            print(f"\nDescargando {len(selected_files)} archivos seleccionados...")
                            downloaded = 0
                            
                            for file in selected_files:
                                try:
                                    # Descargar el archivo
                                    self.repo_manager._download_file(
                                        self.project_key, self.repo_slug, file["path"], 
                                        download_dir, self.current_branch
                                    )
                                    downloaded += 1
                                except Exception as download_e:
                                    print(f"Error descargando {file['path']}: {download_e}")
                            
                            print(f"\n‚úÖ Se descargaron {downloaded} archivos seleccionados en: {download_dir}")
                        else:
                            print("\n‚ùå No se seleccionaron archivos v√°lidos.")
                    except Exception as e:
                        print(f"\n‚ùå Error en la selecci√≥n de archivos: {e}")
        else:
            print("\nNo se encontraron archivos de c√≥digo en este repositorio.")
            
            # Intentar m√©todo alternativo
            try:
                print("\nIntentando m√©todo alternativo para encontrar archivos...")
                
                # Probar explorando manualmente algunas rutas comunes
                common_paths = ["src", "lib", "app", "main", "docs", "tests", "IA", "proyectos", 
                               "innovacion", "BI", "rag_sescol", "seleccion_personal"]
                
                found_files = []
                
                for path in common_paths:
                    try:
                        contents = self.repo_manager.get_folder_contents(
                            self.project_key, self.repo_slug, path, self.current_branch
                        )
                        
                        if contents and not all(item.get("suggested", False) for item in contents):
                            # Filtrar solo archivos
                            path_files = [item for item in contents if item["type"] == "file"]
                            
                            if path_files:
                                print(f"Encontrados {len(path_files)} archivos en la ruta '{path}'")
                                found_files.extend(path_files)
                                
                                # Tambi√©n explorar un nivel m√°s profundo si hay directorios
                                dirs = [item for item in contents if item["type"] == "directory"]
                                
                                for dir_item in dirs:
                                    try:
                                        subdir_path = dir_item["path"]
                                        subdir_contents = self.repo_manager.get_folder_contents(
                                            self.project_key, self.repo_slug, subdir_path, self.current_branch
                                        )
                                        
                                        if subdir_contents:
                                            subdir_files = [item for item in subdir_contents if item["type"] == "file"]
                                            
                                            if subdir_files:
                                                print(f"Encontrados {len(subdir_files)} archivos en '{subdir_path}'")
                                                found_files.extend(subdir_files)
                                    except:
                                        pass
                    except:
                        pass
                
                if found_files:
                    print(f"\nSe encontraron {len(found_files)} archivos en rutas comunes:")
                    
                    for i, file in enumerate(found_files):
                        print(f"{i+1}. {file['path']}")
                    
                    # Ofrecer descargar estos archivos
                    download_all = input("\n¬øDesea descargar todos estos archivos? (s/n): ").lower() == "s"
                    
                    if download_all:
                        # Crear directorio para la descarga
                        download_dir = OUTPUT_DIR / f"{self.repo_slug}_archivos_encontrados"
                        download_dir.mkdir(parents=True, exist_ok=True)
                        
                        # Descargar cada archivo
                        print(f"\nDescargando {len(found_files)} archivos...")
                        downloaded = 0
                        
                        for file in found_files:
                            try:
                                self.repo_manager._download_file(
                                    self.project_key, self.repo_slug, file["path"], 
                                    download_dir, self.current_branch
                                )
                                downloaded += 1
                            except Exception as download_e:
                                print(f"Error descargando {file['path']}: {download_e}")
                        
                        print(f"\n‚úÖ Se descargaron {downloaded} archivos en: {download_dir}")
                else:
                    print("\nNo se encontraron archivos en rutas comunes.")
            except Exception as alt_e:
                print(f"Error en b√∫squeda alternativa: {alt_e}")
        
        input("\nPresione Enter para continuar...")


async def main():
    """Funci√≥n principal."""
    try:
        explorer = RepositoryExplorer()
        await explorer.run()
    except KeyboardInterrupt:
        print("\n\nOperaci√≥n cancelada por el usuario.")
        sys.exit(0)
    except Exception as e:
        logger.error(f"Error inesperado: {e}")
        print(f"\n‚ùå Error inesperado: {str(e)}")
        sys.exit(1)


if __name__ == "__main__":
    # Ejecutar la funci√≥n principal con asyncio
    asyncio.run(main())